<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ ph·ªèng Insertion Sort</title>
    <style>
         :root {
            color-scheme: light dark;
            font-family: "Segoe UI", system-ui, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 2rem clamp(1rem, 5vw, 4rem);
            background: linear-gradient(135deg, #0f172a, #1d2b64);
            color: #f8fafc;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 1.2rem;
            font-size: 1.08rem;
            line-height: 1.45;
        }
        
        header {
            text-align: center;
        }
        
        h1 {
            margin-bottom: 0.4rem;
            font-size: clamp(2rem, 4vw, 3rem);
        }
        
        p.sub {
            margin: 0;
            color: #cbd5f5;
            font-size: 1.05rem;
        }
        
        main {
            display: grid;
            gap: 1.5rem;
        }
        
        .two-columns {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1.5rem;
            align-items: start;
        }
        
        .code-section {
            min-width: fit-content;
            max-width: 600px;
        }
        
        @media (max-width: 1024px) {
            .two-columns {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 18px;
            padding: clamp(0.8rem, 2.5vw, 1.4rem);
            box-shadow: 0 20px 30px rgba(2, 6, 23, 0.3);
        }
        
        .flex {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .step {
            flex: 1 1 220px;
            border-left: 4px solid #38bdf8;
            padding-left: 1rem;
        }
        
        .algo {
            font-family: "Fira Code", "SFMono-Regular", Consolas, monospace;
            background: rgba(15, 23, 42, 0.9);
            padding: 1rem;
            border-radius: 12px;
            overflow-x: auto;
            line-height: 1.6;
        }
        
        .algo code {
            display: block;
            color: #f8fafc;
            white-space: pre;
            font-size: 0.98em;
        }
        
        .code-line {
            display: block;
            padding: 0 0.75rem;
            margin: 0 -0.75rem;
            border-left: 3px solid transparent;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.4;
        }
        
        .code-line.active {
            background: rgba(56, 189, 248, 0.25);
            border-color: #38bdf8;
            opacity: 1;
            transform: translateX(4px);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
        }
        
        .token-preproc {
            color: #f472b6;
        }
        
        .token-keyword {
            color: #38bdf8;
        }
        
        .token-type {
            color: #a5b4fc;
        }
        
        .token-func {
            color: #4ade80;
        }
        
        .token-number {
            color: #facc15;
        }
        
        .token-comment {
            color: #94a3b8;
            font-style: italic;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8rem;
            align-items: center;
        }
        
        .custom-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            gap: 0.8rem;
            margin-top: 1rem;
        }
        
        label {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        input[type="number"],
        input[type="text"],
        input[type="range"] {
            border: 1px solid rgba(148, 163, 184, 0.4);
            border-radius: 999px;
            padding: 0.5rem 0.9rem;
            background: rgba(15, 23, 42, 0.7);
            color: #f8fafc;
            font-size: 1rem;
        }
        
        input[type="text"] {
            border-radius: 12px;
        }
        
        .custom-actions {
            display: flex;
            gap: 0.6rem;
            flex-wrap: wrap;
            align-items: flex-end;
        }
        
        .button-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        button {
            border: none;
            padding: 0.8rem 1.6rem;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.03em;
            background: #38bdf8;
            color: #0f172a;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        button:disabled {
            background: #475569;
            color: #cbd5f5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        
        button:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 15px 25px rgba(56, 189, 248, 0.3);
        }
        
        .bars {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 260px;
            padding: 3rem 2rem;
            margin-top: 1rem;
            position: relative;
        }
        
        .bar {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 16px;
            position: absolute;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            color: white;
            top: 50%;
            transform: translateY(-50%);
            will-change: transform, left, box-shadow;
        }
        
        .bar.lifting {
            background: linear-gradient(135deg, #fef08a 0%, #facc15 100%);
            border-color: #eab308;
            box-shadow: 0 12px 30px rgba(250, 204, 21, 0.6), 
                        0 0 25px rgba(250, 204, 21, 0.4),
                        0 0 50px rgba(250, 204, 21, 0.2);
            z-index: 20;
            filter: brightness(1.1);
        }
        
        .bar.comparing {
            background: linear-gradient(135deg, #c4b5fd 0%, #a78bfa 100%);
            border-color: #8b5cf6;
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.5),
                        0 0 15px rgba(139, 92, 246, 0.3);
            filter: brightness(1.05);
        }
        
        .bar.shifting {
            background: linear-gradient(135deg, #fca5a5 0%, #f87171 100%);
            border-color: #ef4444;
            box-shadow: 0 6px 18px rgba(239, 68, 68, 0.5);
        }
        
        .bar.sorted {
            background: linear-gradient(135deg, #86efac 0%, #22c55e 100%);
            border-color: #16a34a;
            box-shadow: 0 6px 15px rgba(34, 197, 94, 0.5);
            animation: sorted-pop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .bar.inserting {
            background: linear-gradient(135deg, #fef08a 0%, #facc15 100%);
            border-color: #eab308;
            box-shadow: 0 12px 30px rgba(250, 204, 21, 0.6), 
                        0 0 25px rgba(250, 204, 21, 0.4),
                        0 0 50px rgba(250, 204, 21, 0.2);
            z-index: 25;
            filter: brightness(1.1);
        }
        
        @keyframes sorted-pop {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        
        
        .status {
            font-size: 1.1rem;
            font-weight: 600;
            color: #38bdf8;
            min-height: 1.3em;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(56, 189, 248, 0.3);
            margin-top: 1rem;
        }
        
        .log-container {
            margin-top: 1rem;
            background: rgba(15, 23, 42, 0.9);
            border-radius: 12px;
            padding: 1rem;
            max-height: 200px;
            overflow-y: auto;
            font-family: "Fira Code", "SFMono-Regular", Consolas, monospace;
            font-size: 0.9rem;
        }
        
        .log-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .log-container::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 4px;
        }
        
        .log-container::-webkit-scrollbar-thumb {
            background: rgba(56, 189, 248, 0.5);
            border-radius: 4px;
        }
        
        .log-container::-webkit-scrollbar-thumb:hover {
            background: rgba(56, 189, 248, 0.7);
        }
        
        
        .log-entry {
            padding: 0.4rem 0.6rem;
            margin: 0.2rem 0;
            border-radius: 6px;
            border-left: 3px solid #475569;
            background: rgba(30, 41, 59, 0.5);
            transition: all 0.3s ease;
        }
        
        .log-entry.active {
            background: rgba(56, 189, 248, 0.2);
            border-left-color: #38bdf8;
            transform: translateX(5px);
        }
        
        .log-entry.select { border-left-color: #facc15; }
        .log-entry.compare { border-left-color: #a78bfa; }
        .log-entry.shift { border-left-color: #f87171; }
        .log-entry.insert { border-left-color: #22c55e; }
        
        footer {
            text-align: center;
            color: #94a3b8;
            font-size: 0.9rem;
        }
        
        @media (max-width: 640px) {
            .bars {
                gap: 0.4rem;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>Insertion Sort</h1>
        <p class="sub">Quan s√°t c√°ch t·ª´ng ph·∫ßn t·ª≠ t√¨m v·ªã tr√≠ ƒë√∫ng c·ªßa n√≥ trong m·∫£ng ƒë√£ s·∫Øp x·∫øp</p>
    </header>

    <main>
        <div class="two-columns">
            <section class="card">
                <h2>M√¥ ph·ªèng</h2>
                <div class="controls">
                    <button id="playBtn">‚ñ∂Ô∏è Play</button>
                    <button id="pauseBtn" disabled>‚è∏Ô∏è Pause</button>
                    <button id="stepBackBtn" disabled>‚èÆÔ∏è Step Back</button>
                    <button id="stepForwardBtn" disabled>‚è≠Ô∏è Step Forward</button>
                    <button id="resetBtn">üîÑ Reset</button>
                    <button id="shuffleBtn">üîÄ Shuffle</button>
                    <label>
              T·ªëc ƒë·ªô:
              <input id="speed" type="range" min="300" max="2500" step="100" value="1000">
            </label>
                </div>
                <div class="status" id="status">Nh·∫•n Play ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                <div class="status" style="font-size: 0.95rem; margin-top: 0.5rem;" id="stepInfo"></div>
                <div class="custom-inputs">
                    <div class="custom-actions">
                        <label>
                S·ªë ph·∫ßn t·ª≠ (2-15)
                <input id="countInput" type="number" min="2" max="15" value="7">
              </label>
                        <div class="button-group">
                            <button id="applyCountBtn">√Åp d·ª•ng s·ªë l∆∞·ª£ng</button>
                            <button id="randomCountBtn">Ng·∫´u nhi√™n s·ªë l∆∞·ª£ng</button>
                        </div>
                    </div>
                    <div class="custom-actions">
                        <label>
                Nh·∫≠p gi√° tr·ªã tu·ª≥ ch·ªânh (c√°ch nhau b·∫±ng d·∫•u ph·∫©y)
                <input id="valuesInput" type="text" placeholder="V√≠ d·ª•: 8, 3, 12, 1">
              </label>
                        <div class="button-group">
                            <button id="randomValuesBtn">Ng·∫´u nhi√™n ph·∫ßn t·ª≠</button>
                            <button id="applyValuesBtn">√Åp d·ª•ng m·∫£ng</button>
                        </div>
                    </div>
                </div>
                <div class="bars" id="bars"></div>
                <div class="log-container" id="logContainer"></div>
            </section>

            <section class="card code-section">
                <h2>Code m√¥ ph·ªèng</h2>
                <pre class="algo"><code><span class="code-line" data-line="signature"><span class="token-keyword">void</span> <span class="token-func">insertionSort</span>(vector&lt;<span class="token-type">int</span>&gt;&amp; arr) {</span>

<span class="code-line" data-line="for-loop">  <span class="token-keyword">for</span> (int i = <span class="token-number">1</span>; i &lt; arr.size(); i++) {</span>
<span class="code-line" data-line="key-assign">    <span class="token-type">int</span> key = arr[i];</span>
<span class="code-line" data-line="j-assign">    <span class="token-type">int</span> j = i - <span class="token-number">1</span>;</span>
<span class="code-line" data-line="while-condition">    <span class="token-keyword">while</span> (j &gt;= <span class="token-number">0</span> &amp;&amp; arr[j] &gt; key) {</span>
<span class="code-line" data-line="shift-line">      arr[j + <span class="token-number">1</span>] = arr[j];</span>
<span class="code-line" data-line="decrement-line">      j--;</span>
<span class="code-line" data-line="while-end">    }</span>
<span class="code-line" data-line="insert-line">    arr[j + <span class="token-number">1</span>] = key;</span>
<span class="code-line" data-line="for-end">  }</span>
<span class="code-line" data-line="closing-brace">}</span></code></pre>
            </section>
        </div>

        <section class="card flex">
            <article class="step">
                <h3>1. Chia nh·ªè v·∫•n ƒë·ªÅ</h3>
                <p>Xem m·∫£ng nh∆∞ hai ph·∫ßn: ƒëo·∫°n ƒë·∫ßu ƒë√£ s·∫Øp x·∫øp v√† ph·∫ßn c√≤n l·∫°i ch∆∞a s·∫Øp x·∫øp.</p>
            </article>
            <article class="step">
                <h3>2. L·∫•y ph·∫ßn t·ª≠ k·∫ø ti·∫øp</h3>
                <p>N·ªëi ti·∫øp t·ª´ tr√°i sang ph·∫£i, ch·ªçn ph·∫ßn t·ª≠ ti·∫øp theo v√† g·ªçi n√≥ l√† <em>key</em>.</p>
            </article>
            <article class="step">
                <h3>3. ƒê·∫©y c√°c ph·∫ßn t·ª≠ l·ªõn h∆°n</h3>
                <p>D·ªãch chuy·ªÉn c√°c ph·∫ßn t·ª≠ l·ªõn h∆°n key sang ph·∫£i ƒë·ªÉ t·∫°o kho·∫£ng tr·ªëng.</p>
            </article>
            <article class="step">
                <h3>4. C·∫Øm key v√†o ch·ªó ƒë√∫ng</h3>
                <p>Ch√®n key v√†o kho·∫£ng tr·ªëng ƒë√£ t·∫°o. L·∫∑p l·∫°i cho ƒë·∫øn khi h·∫øt m·∫£ng.</p>
            </article>
        </section>

        <section class="card">
            <h2>ƒê·∫∑c ƒëi·ªÉm n·ªïi b·∫≠t</h2>
            <ul>
                <li>ƒê·ªô ph·ª©c t·∫°p t·ªët nh·∫•t: O(n) v·ªõi m·∫£ng g·∫ßn nh∆∞ s·∫Øp x·∫øp.</li>
                <li>Trung b√¨nh/x·∫•u nh·∫•t: O(n¬≤) do l·∫∑p l·ªìng nhau.</li>
                <li>S·∫Øp x·∫øp t·∫°i ch·ªó, ch·ªâ c·∫ßn th√™m 1 √¥ nh·ªõ ph·ª•.</li>
                <li>·ªîn ƒë·ªãnh: c√°c ph·∫ßn t·ª≠ b·∫±ng nhau gi·ªØ nguy√™n th·ª© t·ª± ban ƒë·∫ßu.</li>
            </ul>
        </section>
    </main>

    <footer>ƒê∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ gi√∫p b·∫°n c·∫£m nh·∫≠n nh·ªãp ƒëi·ªáu c·ªßa insertion sort.</footer>

    <script>
        // ============================================
        // DOM ELEMENTS
        // ============================================
        const barsEl = document.getElementById("bars");
        const statusEl = document.getElementById("status");
        const stepInfoEl = document.getElementById("stepInfo");
        const logContainerEl = document.getElementById("logContainer");
        const playBtn = document.getElementById("playBtn");
        const pauseBtn = document.getElementById("pauseBtn");
        const stepBackBtn = document.getElementById("stepBackBtn");
        const stepForwardBtn = document.getElementById("stepForwardBtn");
        const resetBtn = document.getElementById("resetBtn");
        const shuffleBtn = document.getElementById("shuffleBtn");
        const speedInput = document.getElementById("speed");
        const countInput = document.getElementById("countInput");
        const applyCountBtn = document.getElementById("applyCountBtn");
        const randomCountBtn = document.getElementById("randomCountBtn");
        const valuesInput = document.getElementById("valuesInput");
        const randomValuesBtn = document.getElementById("randomValuesBtn");
        const applyValuesBtn = document.getElementById("applyValuesBtn");
        const codeLines = document.querySelectorAll(".code-line");

        // ============================================
        // CONSTANTS
        // ============================================
        const MIN_COUNT = 2;
        const MAX_COUNT = 15;

        // ============================================
        // STATE VARIABLES
        // ============================================
        let originalValues = [32, 11, 45, 6, 28, 14, 50];
        let steps = [];
        let currentStepIndex = -1;
        let isPlaying = false;
        let playTimer = null;
        
        // Track each element's position (value -> position mapping)
        let elementPositions = {};

        // ============================================
        // STEP GENERATION
        // ============================================
        function generateSteps(arr) {
            const steps = [];
            const array = [...arr];
            
            // Create a mapping of each unique value to track its position
            // Since we might have duplicates, we'll use value_index as unique ID
            const elements = array.map((value, idx) => ({
                id: `${value}_${idx}`,
                value: value,
                position: idx
            }));
            
            // Initial state
            steps.push({
                array: [...array],
                elements: elements.map(e => ({...e})),
                i: null,
                j: null,
                key: null,
                keyElementId: null,
                actionText: "Tr·∫°ng th√°i ban ƒë·∫ßu - M·∫£ng ch∆∞a ƒë∆∞·ª£c s·∫Øp x·∫øp",
                actionType: "init",
                keyIndex: null,
                compareIndex: null,
                sortedUpTo: 0,
                codeLine: null,
                shiftingIndices: [],
                insertPosition: null
            });

            for (let i = 1; i < array.length; i++) {
                const key = array[i];
                const keyElement = elements.find(e => e.position === i);
                
                let j = i - 1;
                let needsToMove = false;
                
                // Check if key needs to move
                let tempJ = j;
                while (tempJ >= 0 && array[tempJ] > key) {
                    needsToMove = true;
                    tempJ--;
                }
                
                // Only lift key if it needs to move
                if (needsToMove) {
                    // Select key - lift it up
                    steps.push({
                        array: [...array],
                        elements: elements.map(e => ({...e})),
                        i: i,
                        j: i - 1,
                        key: key,
                        keyElementId: keyElement.id,
                        actionText: `Ch·ªçn ph·∫ßn t·ª≠ key = ${key} t·∫°i v·ªã tr√≠ ${i} v√† nh·∫•c l√™n`,
                        actionType: "select",
                        keyIndex: i,
                        compareIndex: null,
                        sortedUpTo: i - 1,
                        codeLine: "key-assign",
                        shiftingIndices: [],
                        insertPosition: null
                    });
                } else {
                    // Key is already in correct position
                    steps.push({
                        array: [...array],
                        elements: elements.map(e => ({...e})),
                        i: i,
                        j: i - 1,
                        key: key,
                        keyElementId: keyElement.id,
                        actionText: `Ph·∫ßn t·ª≠ ${key} ƒë√£ ·ªü ƒë√∫ng v·ªã tr√≠`,
                        actionType: "already-sorted",
                        keyIndex: i,
                        compareIndex: null,
                        sortedUpTo: i,
                        codeLine: "key-assign",
                        shiftingIndices: [],
                        insertPosition: null
                    });
                    continue;
                }
                
                // Compare and shift
                while (j >= 0 && array[j] > key) {
                    // Compare
                    steps.push({
                        array: [...array],
                        elements: elements.map(e => ({...e})),
                        i: i,
                        j: j,
                        key: key,
                        keyElementId: keyElement.id,
                        actionText: `So s√°nh: array[${j}] = ${array[j]} > key = ${key}`,
                        actionType: "compare",
                        keyIndex: i,
                        compareIndex: j,
                        sortedUpTo: i - 1,
                        codeLine: "while-condition",
                        shiftingIndices: [],
                        insertPosition: null
                    });

                    // Shift - slide right
                    const shiftingValue = array[j];
                    const shiftingElement = elements.find(e => e.position === j);
                    
                    // Update positions in elements array
                    shiftingElement.position = j + 1;
                    array[j + 1] = array[j];
                    
                    steps.push({
                        array: [...array],
                        elements: elements.map(e => ({...e})),
                        i: i,
                        j: j,
                        key: key,
                        keyElementId: keyElement.id,
                        actionText: `D·ªãch ${shiftingValue} sang ph·∫£i t·ª´ v·ªã tr√≠ ${j} ‚Üí ${j + 1}`,
                        actionType: "shift",
                        keyIndex: i,
                        compareIndex: null,
                        sortedUpTo: i - 1,
                        codeLine: "shift-line",
                        shiftingIndices: [j + 1],
                        insertPosition: j + 1
                    });

                    j--;
                }

                // Check if we need to show the comparison that breaks the loop
                if (j >= 0) {
                    steps.push({
                        array: [...array],
                        elements: elements.map(e => ({...e})),
                        i: i,
                        j: j,
                        key: key,
                        keyElementId: keyElement.id,
                        actionText: `So s√°nh: array[${j}] = ${array[j]} ‚â§ key = ${key} - D·ª´ng d·ªãch chuy·ªÉn`,
                        actionType: "compare",
                        keyIndex: i,
                        compareIndex: j,
                        sortedUpTo: i - 1,
                        codeLine: "while-condition",
                        shiftingIndices: [],
                        insertPosition: null
                    });
                }

                // Insert key - move to final position with intermediate steps
                const finalPosition = j + 1;
                const originalPosition = i;
                
                // Step 1: Key moves horizontally to target column (while staying up)
                if (finalPosition !== originalPosition) {
                    steps.push({
                        array: [...array],
                        elements: elements.map(e => ({...e})),
                        i: i,
                        j: j,
                        key: key,
                        keyElementId: keyElement.id,
                        actionText: `Key = ${key} di chuy·ªÉn sang tr√°i ƒë·∫øn c·ªôt ${finalPosition}`,
                        actionType: "move-horizontal",
                        keyIndex: finalPosition,
                        compareIndex: null,
                        sortedUpTo: i - 1,
                        codeLine: "insert-line",
                        shiftingIndices: [],
                        insertPosition: finalPosition,
                        keyTargetPosition: finalPosition
                    });
                }
                
                // Step 2: Key drops down to final position
                keyElement.position = finalPosition;
                array[j + 1] = key;
                
                steps.push({
                    array: [...array],
                    elements: elements.map(e => ({...e})),
                    i: i,
                    j: j,
                    key: key,
                    keyElementId: keyElement.id,
                    actionText: `Ch√®n key = ${key} v√†o v·ªã tr√≠ ${finalPosition}`,
                    actionType: "insert",
                    keyIndex: finalPosition,
                    compareIndex: null,
                    sortedUpTo: i,
                    codeLine: "insert-line",
                    shiftingIndices: [],
                    insertPosition: finalPosition
                });
            }

            // Final sorted state
            steps.push({
                array: [...array],
                elements: elements.map(e => ({...e})),
                i: null,
                j: null,
                key: null,
                keyElementId: null,
                actionText: "Ho√†n t·∫•t! M·∫£ng ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp",
                actionType: "complete",
                keyIndex: null,
                compareIndex: null,
                sortedUpTo: array.length - 1,
                codeLine: null,
                shiftingIndices: [],
                insertPosition: null
            });

            return steps;
        }

        // ============================================
        // RENDERING FUNCTIONS
        // ============================================
        function renderBars(step) {
            barsEl.innerHTML = "";
            const elements = step.elements;
            const GAP = 12;
            const BAR_WIDTH = 80;
            const UNIT = BAR_WIDTH + GAP;
            
            // Calculate total width and center offset
            const totalWidth = elements.length * UNIT - GAP;
            const containerWidth = barsEl.offsetWidth || 800;
            const startOffset = (containerWidth - totalWidth) / 2;

            elements.forEach((element) => {
                const bar = document.createElement("div");
                bar.className = "bar";
                bar.textContent = element.value;
                bar.dataset.id = element.id;

                // Calculate position based on element's current position (centered)
                let xPos = startOffset + (element.position * UNIT);
                let yOffset = 0;

                // Apply classes and position adjustments based on step type
                if (element.position <= step.sortedUpTo && step.actionType === "complete") {
                    bar.classList.add("sorted");
                }

                // Key is being selected and lifted up
                if (step.keyElementId === element.id) {
                    if (step.actionType === "select") {
                        bar.classList.add("lifting");
                        yOffset = -80;
                    }
                    else if (step.actionType === "compare") {
                        bar.classList.add("lifting");
                        yOffset = -80;
                    }
                    else if (step.actionType === "shift") {
                        bar.classList.add("lifting");
                        yOffset = -80;
                    }
                    else if (step.actionType === "move-horizontal") {
                        bar.classList.add("lifting");
                        yOffset = -80;
                        // Move to target position horizontally (centered)
                        xPos = startOffset + (step.keyTargetPosition * UNIT);
                    }
                    else if (step.actionType === "insert") {
                        bar.classList.add("inserting");
                        yOffset = 0;
                    }
                    else if (step.actionType === "already-sorted") {
                        bar.classList.add("sorted");
                    }
                }

                // Element being compared
                if (step.compareIndex !== null && element.position === step.compareIndex) {
                    bar.classList.add("comparing");
                }

                // Element being shifted
                if (step.shiftingIndices && step.shiftingIndices.includes(element.position)) {
                    bar.classList.add("shifting");
                }

                // Apply position
                bar.style.left = `${xPos}px`;
                bar.style.transform = `translateY(calc(-50% + ${yOffset}px))`;

                barsEl.appendChild(bar);
            });
        }

        function updateStatus(step) {
            const icons = {
                init: "üî∑",
                select: "üéØ",
                compare: "üîç",
                shift: "‚û°Ô∏è",
                insert: "‚ú®",
                complete: "üéâ"
            };
            const icon = icons[step.actionType] || "üìå";
            statusEl.textContent = `${icon} ${step.actionText}`;
            
            // Update step info
            stepInfoEl.textContent = `Step ${currentStepIndex + 1}/${steps.length} | i=${step.i ?? "-"} | j=${step.j ?? "-"} | key=${step.key ?? "-"}`;
        }

        function setCodeHighlight(lineKey) {
            codeLines.forEach((line) => {
                line.classList.toggle(
                    "active",
                    Boolean(lineKey) && line.dataset.line === lineKey
                );
            });
        }

        function addLog(step, index) {
            const logEntry = document.createElement("div");
            logEntry.className = `log-entry ${step.actionType}`;
            logEntry.textContent = `[${index}] ${step.actionText}`;
            logEntry.dataset.index = index;
            logEntry.addEventListener("click", () => {
                goToStep(index);
            });
            logContainerEl.appendChild(logEntry);
        }

        function updateLogHighlight() {
            const logEntries = logContainerEl.querySelectorAll(".log-entry");
            logEntries.forEach((entry, idx) => {
                entry.classList.toggle("active", idx === currentStepIndex);
            });
            
            // Scroll to active log
            const activeLog = logContainerEl.querySelector(".log-entry.active");
            if (activeLog) {
                activeLog.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
        }

        function renderLogs() {
            logContainerEl.innerHTML = "";
            steps.forEach((step, index) => {
                addLog(step, index);
            });
        }

        // ============================================
        // STEP APPLICATION
        // ============================================
        function applyStep(index) {
            if (index < 0 || index >= steps.length) return;
            
            currentStepIndex = index;
            const step = steps[index];
            
            renderBars(step);
            updateStatus(step);
            setCodeHighlight(step.codeLine);
            updateLogHighlight();
            updateButtons();
        }

        // ============================================
        // BUTTON STATE MANAGEMENT
        // ============================================
        function updateButtons() {
            const hasSteps = steps.length > 0;
            const canGoBack = currentStepIndex > 0;
            const canGoForward = currentStepIndex < steps.length - 1;
            const isAtStart = currentStepIndex <= 0;
            const isAtEnd = currentStepIndex >= steps.length - 1;

            playBtn.disabled = isPlaying || isAtEnd || !hasSteps;
            pauseBtn.disabled = !isPlaying;
            stepBackBtn.disabled = !canGoBack || isPlaying;
            stepForwardBtn.disabled = !canGoForward || isPlaying;
            resetBtn.disabled = isAtStart && !isPlaying;
            shuffleBtn.disabled = isPlaying;
            applyCountBtn.disabled = isPlaying;
            randomCountBtn.disabled = isPlaying;
            applyValuesBtn.disabled = isPlaying;
            randomValuesBtn.disabled = isPlaying;
        }

        // ============================================
        // PLAYBACK CONTROL
        // ============================================
        function play() {
            if (isPlaying) return;
            
            isPlaying = true;
            updateButtons();
            
            function playNextStep() {
                if (!isPlaying) return;
                
                if (currentStepIndex < steps.length - 1) {
                    stepForward();
                    const delay = Number(speedInput.value);
                    playTimer = setTimeout(playNextStep, delay);
                } else {
                    pause();
                }
            }
            
            playNextStep();
        }

        function pause() {
            isPlaying = false;
            if (playTimer) {
                clearTimeout(playTimer);
                playTimer = null;
            }
            updateButtons();
        }

        function stepForward() {
            if (currentStepIndex < steps.length - 1) {
                applyStep(currentStepIndex + 1);
            }
        }

        function stepBack() {
            if (currentStepIndex > 0) {
                applyStep(currentStepIndex - 1);
            }
        }

        function reset() {
            pause();
            currentStepIndex = -1;
            steps = generateSteps(originalValues);
            renderLogs();
            applyStep(0);
        }

        function goToStep(index) {
            pause();
            applyStep(index);
        }

        // ============================================
        // ARRAY MANIPULATION
        // ============================================
        function generateRandomArray(count, min = 10, max = 99) {
            return Array.from({
                length: count
            }, () =>
                Math.floor(Math.random() * (max - min + 1)) + min
            );
        }

        function shuffleValues() {
            if (isPlaying) return;
            
            originalValues = originalValues
                .map((value) => ({
                    value,
                    sort: Math.random()
                }))
                .sort((a, b) => a.sort - b.sort)
                .map(({ value }) => value);
            
            valuesInput.value = originalValues.join(", ");
            reset();
            statusEl.textContent = "üîÄ M·∫£ng ƒë√£ ƒë∆∞·ª£c tr·ªôn";
        }

        function updateValuesFromCount() {
            if (isPlaying) return;
            
            let count = Number(countInput.value);
            if (!Number.isFinite(count)) count = originalValues.length;
            count = Math.min(Math.max(count, MIN_COUNT), MAX_COUNT);
            countInput.value = count;
            
            originalValues = generateRandomArray(count);
            valuesInput.value = originalValues.join(", ");
            reset();
            statusEl.textContent = `‚úÖ ƒê√£ t·∫°o ${count} ph·∫ßn t·ª≠ ng·∫´u nhi√™n`;
        }

        function randomizeCount() {
            if (isPlaying) return;
            
            const randomCount = Math.floor(Math.random() * (MAX_COUNT - MIN_COUNT + 1)) + MIN_COUNT;
            countInput.value = randomCount;
            updateValuesFromCount();
        }

        function updateValuesFromInput() {
            if (isPlaying) return;
            
            const raw = valuesInput.value.trim();
            if (!raw) {
                statusEl.textContent = "‚ö†Ô∏è Vui l√≤ng nh·∫≠p √≠t nh·∫•t 2 gi√° tr·ªã";
                return;
            }

            const parsed = raw
                .split(/[, ]+/)
                .map((chunk) => chunk.trim())
                .filter(Boolean)
                .map(Number);

            if (parsed.some((num) => !Number.isFinite(num))) {
                statusEl.textContent = "‚ö†Ô∏è Ch·ªâ nh·∫≠p s·ªë nguy√™n, c√°ch nhau b·∫±ng d·∫•u ph·∫©y";
                return;
            }

            if (parsed.length < MIN_COUNT || parsed.length > MAX_COUNT) {
                statusEl.textContent = `‚ö†Ô∏è S·ªë ph·∫ßn t·ª≠ ph·∫£i t·ª´ ${MIN_COUNT} ƒë·∫øn ${MAX_COUNT}`;
                return;
            }

            originalValues = parsed.map((num) => Math.max(1, Math.min(120, Math.round(num))));
            countInput.value = originalValues.length;
            reset();
            statusEl.textContent = "‚úÖ ƒê√£ √°p d·ª•ng m·∫£ng tu·ª≥ ch·ªânh";
        }

        function randomizeValues() {
            if (isPlaying) return;
            
            originalValues = generateRandomArray(originalValues.length);
            valuesInput.value = originalValues.join(", ");
            reset();
            statusEl.textContent = "üé≤ ƒê√£ t·∫°o ng·∫´u nhi√™n gi√° tr·ªã cho t·ª´ng ph·∫ßn t·ª≠";
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        playBtn.addEventListener("click", play);
        pauseBtn.addEventListener("click", pause);
        stepBackBtn.addEventListener("click", stepBack);
        stepForwardBtn.addEventListener("click", stepForward);
        resetBtn.addEventListener("click", reset);
        shuffleBtn.addEventListener("click", shuffleValues);
        applyCountBtn.addEventListener("click", updateValuesFromCount);
        randomCountBtn.addEventListener("click", randomizeCount);
        randomValuesBtn.addEventListener("click", randomizeValues);
        applyValuesBtn.addEventListener("click", updateValuesFromInput);
        
        speedInput.addEventListener("input", () => {
            statusEl.textContent = `‚è±Ô∏è T·ªëc ƒë·ªô: ${speedInput.value} ms/b∆∞·ªõc`;
        });

        // ============================================
        // INITIALIZATION
        // ============================================
        countInput.value = originalValues.length;
        valuesInput.value = originalValues.join(", ");
        reset();
    </script>
</body>

</html>
